using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VampirioCode.Command.MSVC.Params;
using VampirioCode.Command.MSVC.Result;
using VampirioCode.Environment;
using VampirioCode.IO;
using VampirioCode.SaveData;
using VampirioCode.UI;

namespace VampirioCode.Command.MSVC
{
    public class MSVC : BaseCmdProgram
    {
        public static string ProgramPath = "";      //@"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\bin\Hostx64\x64\cl.exe"; // 14.38.33130 [working]
        public static string LibProgramPath = "";   //@"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\bin\Hostx64\x64\lib.exe"; // 14.38.33130 [working]

        /// <summary>
        /// Compile the program using the src .cpp files, optional headers, libraries, etc.
        /// </summary>
        /// <param name="sources">Source files. E.g: main.cpp or data.cpp</param>
        /// <param name="outputFilename">
        /// The /OUT option overrides the default name and location of the program that the linker creates.
        /// By default, the linker forms the file name using the base name of the first.obj file specified and the appropriate extension (.exe or .dll).
        /// </param>
        /// <param name="outputObjsDir">
        /// You can use the /Fo compiler option to set an output directory for all the object files generated by the CL compiler command. Or, you can use it to rename a single object file.
        /// </param>
        /// <param name="includes">Include Headers directories. E.g: c:\headers or project\include</param>
        /// <param name="libraryPaths">
        /// Specifies a path that the linker will search before it searches the path specified in the LIB environment option.
        /// E.g: 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\um\x64' or 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\ucrt\x64'
        /// 
        /// Use the /LIBPATH option to override the environment library path. The linker will first search in the path specified by this option,
        /// and then search in the path specified in the LIB environment variable. You can specify only one directory for each /LIBPATH option you
        /// enter. If you want to specify more than one directory, you must specify multiple /LIBPATH options. The linker will then search the specified directories in order.
        /// </param>
        /// <param name="libraryFiles">
        /// The .lib library files that 'LibraryPaths' points to
        /// E.g: libcpmt.lib  kernel32.lib  libucrt.lib
        /// </param>
        /// <param name="exceptionHandlingModel">
        /// Specifies the exception handling model support generated by the compiler. Arguments specify whether to
        /// apply catch(...) syntax to both structured and standard C++ exceptions, whether extern "C" code is assumed to 
        /// throw exceptions, and whether to optimize away certain noexcept checks.
        /// 
        /// a  - /EHa
        ///   Enables standard C++ stack unwinding.Catches both structured (asynchronous) and standard C++ (synchronous) exceptions when you use catch(...) syntax. /EHa overrides both /EHs and /EHc arguments.
        ///
        /// s  - /EHs
        ///   Enables standard C++ stack unwinding. Catches only standard C++ exceptions when you use catch(...) syntax.Unless /EHc is also specified, the compiler assumes that functions declared as extern "C" may throw a C++ exception.
        ///
        /// c  - /EHc
        ///   When used with /EHs, the compiler assumes that functions declared as extern "C" never throw a C++ exception.It has no effect when used with /EHa(that is, /EHca is equivalent to /EHa). /EHc is ignored if /EHs or /EHa aren't specified.
        ///
        /// r  - /EHr
        ///   Tells the compiler to always generate runtime termination checks for all noexcept functions.By default, runtime checks for noexcept may be optimized away if the compiler determines the function calls only non-throwing functions.This option gives strict C++ conformance at the cost of some extra code. /EHr is ignored if /EHs or /EHa aren't specified.
        ///
        /// sc - /EHsc
        ///   A combination of /EHs and /EHc
        /// </param>
        /// <returns></returns>
        public async Task<BuildResult> BuildAsync(List<string> sources, string outputFilename = "", string outputObjsDir = "", List<string> includes = null, List<string> libraryPaths = null, List<string> libraryFiles = null, ExceptionHandlingModel exceptionHandlingModel = ExceptionHandlingModel.EHsc)
        {
            SetupProgramPaths();

            BuildCmd cmd =                  new BuildCmd();
            cmd.Sources =                   sources;
            cmd.OutputFilename =            outputFilename;
            cmd.OutputObjsDir =             outputObjsDir;
            cmd.Includes =                  includes;
            cmd.LibraryPaths =              libraryPaths;
            cmd.LibraryFiles =              libraryFiles;
            cmd.ExceptionHandlingModel =    exceptionHandlingModel;
            SetVariables(cmd);

            var result =                    await cmd.BuildAsync();
            CheckCmd(cmd);
            return result;
        }


        public async Task<BuildResult> BuildAsync(BuildCmd cmd)
        {
            SetupProgramPaths();
            SetVariables(cmd);

            var result = await cmd.BuildAsync();
            CheckCmd(cmd);
            return result;
        }

        public async Task<BuildLibresult> BuildLibAsync(BuildLibCmd cmd)
        {
            SetupProgramPaths();
            SetVariables(cmd);

            var result = await cmd.BuildAsync();
            CheckCmd(cmd);
            return result;
        }

        /// <summary>
        /// Run the compiled executable '.exe'
        /// </summary>
        /// <param name="filename">The executable file '.exe' to run</param>
        /// <returns></returns>
        public async Task<RunResult> RunAsync(string filename)
        {
            SetupProgramPaths();

            RunCmd cmd =    new RunCmd();
            cmd.Filename =  filename;
            SetVariables(cmd);

            var result =    await cmd.RunAsync();
            CheckCmd(cmd);
            return result;
        }

        protected override void SetupProgramPaths()
        {
            ProgramPath =       Config.BuildersSettings.Msvc.cl_exe_path;
            LibProgramPath =    Config.BuildersSettings.Msvc.lib_exe_path;
        }

        protected override void SetVariables(BaseCmd cmd)
        {
            // Includes
            cmd.AddVariable(CppVariables.StlInclude,    Config.BuildersSettings.Msvc.stl_include);
            cmd.AddVariable(CppVariables.UcrtInclude,   Config.BuildersSettings.Msvc.ucrt_include);
            
            // Libraries
            cmd.AddVariable(CppVariables.StlLibDir,     Config.BuildersSettings.Msvc.stl_lib_dir);
            cmd.AddVariable(CppVariables.UmLibDir,      Config.BuildersSettings.Msvc.um_lib_dir);
            cmd.AddVariable(CppVariables.UcrtLibDir,    Config.BuildersSettings.Msvc.ucrt_lib_dir);
        }

    }
}
