using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VampirioCode.Command.MSVC.Result;
using VampirioCode.Command.MSVC.Params;
using System.DirectoryServices.ActiveDirectory;
using System.Xml.Linq;
using Microsoft.VisualBasic.ApplicationServices;
using ScintillaNET;
using System.Numerics;
using System.Windows.Forms;

namespace VampirioCode.Command.MSVC
{
    public class BuildCmd : BaseCmd
    {

        public StandardVersion StandardVersion { get; set; } = StandardVersion.StdCpp17;

        /// <summary>
        /// Specifies the exception handling model support generated by the compiler. Arguments specify whether to
        /// apply catch(...) syntax to both structured and standard C++ exceptions, whether extern "C" code is assumed to 
        /// throw exceptions, and whether to optimize away certain noexcept checks.
        /// 
        /// a  - /EHa
        ///   Enables standard C++ stack unwinding.Catches both structured (asynchronous) and standard C++ (synchronous) exceptions when you use catch(...) syntax. /EHa overrides both /EHs and /EHc arguments.
        ///
        /// s  - /EHs
        ///   Enables standard C++ stack unwinding. Catches only standard C++ exceptions when you use catch(...) syntax.Unless /EHc is also specified, the compiler assumes that functions declared as extern "C" may throw a C++ exception.
        ///
        /// c  - /EHc
        ///   When used with /EHs, the compiler assumes that functions declared as extern "C" never throw a C++ exception.It has no effect when used with /EHa(that is, /EHca is equivalent to /EHa). /EHc is ignored if /EHs or /EHa aren't specified.
        ///
        /// r  - /EHr
        ///   Tells the compiler to always generate runtime termination checks for all noexcept functions.By default, runtime checks for noexcept may be optimized away if the compiler determines the function calls only non-throwing functions.This option gives strict C++ conformance at the cost of some extra code. /EHr is ignored if /EHs or /EHa aren't specified.
        ///
        /// sc - /EHsc
        ///   A combination of /EHs and /EHc
        /// 
        /// </summary>
        public ExceptionHandlingModel ExceptionHandlingModel { get; set; } = ExceptionHandlingModel.EHsc;

        /// <summary>
        /// Include Headers directories. E.g: c:\headers or project\include
        /// </summary>
        public List<string> Includes { get; set; } = new List<string>();

        /// <summary>
        /// Source files. E.g: main.cpp or data.cpp
        /// </summary>
        public List<string> Sources { get; set; }

        /// <summary>
        /// Specifies a path that the linker will search before it searches the path specified in the LIB environment option.
        /// E.g: 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\um\x64' or 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\ucrt\x64'
        /// 
        /// Use the /LIBPATH option to override the environment library path. The linker will first search in the path specified by this option,
        /// and then search in the path specified in the LIB environment variable. You can specify only one directory for each /LIBPATH option you
        /// enter. If you want to specify more than one directory, you must specify multiple /LIBPATH options. The linker will then search the specified directories in order.
        ///
        /// </summary>
        public List<string> LibraryPaths { get; set; } = new List<string>();

        /// <summary>
        /// The .lib library files that 'LibraryPaths' points to
        /// E.g: libcpmt.lib  kernel32.lib  libucrt.lib
        /// </summary>
        public List<string> LibraryFiles { get; set; } = new List<string>();

        /// <summary>
        /// The /OUT option overrides the default name and location of the program that the linker creates.
        /// By default, the linker forms the file name using the base name of the first.obj file specified and the appropriate extension (.exe or .dll).
        /// </summary>
        public string OutputFilename { get; set; } = "";

        /// <summary>
        /// You can use the /Fo compiler option to set an output directory for all the object files generated by the CL compiler command. Or, you can use it to rename a single object file. 
        /// </summary>
        public string OutputObjsDir { get; set; } = "";

        /// <summary>
        /// /D (Preprocessor Definitions)
        /// You can use this symbol together with #if or #ifdef to compile source code conditionally. The symbol definition remains in effect until it's redefined in the code, or is undefined in the code by an #undef directive.
        /// /D has the same effect as a
        /// #define directive at the beginning of a source code file. The difference is that /D strips quotation marks on the command line, and a #define directive keeps them. You can have whitespace between the /D and the symbol. There can't be whitespace between the symbol and the equals sign, or between the equals sign and any value assigned.
        /// By default, the value associated with a symbol is 1. For example, /D name is equivalent to /D name = 1.In the example at the end of this article, the definition of TEST is shown to print 1.
        /// Compiling by using /D name = causes the symbol name to have no associated value.Although the symbol can still be used to conditionally compile code, it otherwise evaluates to nothing.In the example, if you compile by using /DTEST=, an error occurs.This behavior resembles the use of
        /// #define with or without a value.
        /// The /D option doesn't support function-like macro definitions. To insert definitions that can't be defined on the command line, consider the /FI(Name forced include file) compiler option.
        /// You can use /D multiple times on the command line to define more symbols.If the same symbol is defined more than once, the last definition is used.
        /// </summary>
        public List<string> PreprocessorDefinitions { get; set; } = new List<string>();

        public async Task<BuildResult> BuildAsync()
        {
            SetIfExists("/Fo:", _fixLastEscapeBar(OutputObjsDir), false);
            SetIfExists(StandardVersionInfo.Get(StandardVersion).Param);
            SetIfExists(ExceptionHandlingModelInfo.Get(ExceptionHandlingModel).Param);
            SetIncludes(Includes);
            SetPreprocessor(PreprocessorDefinitions);
            SetIfExists(Sources.ToArray());

            if (CanUse(LibraryPaths) || CanUse(LibraryFiles))
            {
                Set("/link");
                SetLibPaths(LibraryPaths);
                SetIfExists(LibraryFiles.ToArray());
            }

            SetIfExists("/OUT:", _fixLastEscapeBar(OutputFilename), false);

            AutoTriggerErrors = false;
            return await CreateCommand<BuildResult>(_quotes(MSVC.ProgramPath), cmd.Trim());
        }

        private void SetIncludes(List<string> includes)
        {
            if ((includes != null) && (includes.Count > 0))
            {
                foreach (string include in includes)
                {
                    string inc = ReplaceVars(include);
                    cmd += "/I\"" + _fixLastEscapeBar(inc) + "\" ";
                }
            }
        }

        private void SetLibPaths(List<string> libraries)
        {
            if ((libraries != null) && (libraries.Count > 0))
            {
                foreach (string library in libraries)
                {
                    string lib = ReplaceVars(library);
                    cmd += "/LIBPATH:\"" + _fixLastEscapeBar(lib) + "\" ";
                }
            }
        }

        private void SetPreprocessor(List<string> preprocessorDefinitions)
        {
            if ((preprocessorDefinitions != null) && (preprocessorDefinitions.Count > 0))
            {
                foreach (string directive in preprocessorDefinitions)
                    cmd += "/D\"" + _fixLastEscapeBar(directive) + "\" ";
            }
        }

        protected override void OnDataReceived(string data)
        {
                 if (data.Contains("): error C"))       CallError(data);
            else if (data.Contains(": fatal error C"))  CallError(data);
            else
                Println("data: " + data);
        }

        protected override void OnErrorDataReceived(string data)
        {
            // not treated as error here because MSVC send non error data on error received event
            Println("data: " + data);
        }

        protected override void OnComplete(BaseResult result)
        {
            Println("[complete]");
        }
    }
}
