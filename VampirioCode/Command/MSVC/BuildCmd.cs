using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VampirioCode.Command.MSVC.Result;
using VampirioCode.Command.MSVC.Params;
using System.DirectoryServices.ActiveDirectory;
using System.Xml.Linq;

namespace VampirioCode.Command.MSVC
{
    public class BuildCmd : BaseCmd
    {

        /// <summary>
        /// Specifies the exception handling model support generated by the compiler. Arguments specify whether to
        /// apply catch(...) syntax to both structured and standard C++ exceptions, whether extern "C" code is assumed to 
        /// throw exceptions, and whether to optimize away certain noexcept checks.
        /// 
        /// a  - /EHa
        ///   Enables standard C++ stack unwinding.Catches both structured (asynchronous) and standard C++ (synchronous) exceptions when you use catch(...) syntax. /EHa overrides both /EHs and /EHc arguments.
        ///
        /// s  - /EHs
        ///   Enables standard C++ stack unwinding. Catches only standard C++ exceptions when you use catch(...) syntax.Unless /EHc is also specified, the compiler assumes that functions declared as extern "C" may throw a C++ exception.
        ///
        /// c  - /EHc
        ///   When used with /EHs, the compiler assumes that functions declared as extern "C" never throw a C++ exception.It has no effect when used with /EHa(that is, /EHca is equivalent to /EHa). /EHc is ignored if /EHs or /EHa aren't specified.
        ///
        /// r  - /EHr
        ///   Tells the compiler to always generate runtime termination checks for all noexcept functions.By default, runtime checks for noexcept may be optimized away if the compiler determines the function calls only non-throwing functions.This option gives strict C++ conformance at the cost of some extra code. /EHr is ignored if /EHs or /EHa aren't specified.
        ///
        /// sc - /EHsc
        ///   A combination of /EHs and /EHc
        /// 
        /// </summary>
        public ExceptionHandlingModel ExceptionHandlingModel { get; set; } = ExceptionHandlingModel.EHsc;

        /// <summary>
        /// Include Headers directories. E.g: c:\headers or project\include
        /// </summary>
        public List<string> Includes { get; set; } = new List<string>();

        /// <summary>
        /// Source files. E.g: main.cpp or data.cpp
        /// </summary>
        public List<string> Sources { get; set; }

        /// <summary>
        /// Specifies a path that the linker will search before it searches the path specified in the LIB environment option.
        /// E.g: 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\um\x64' or 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\ucrt\x64'
        /// 
        /// Use the /LIBPATH option to override the environment library path. The linker will first search in the path specified by this option,
        /// and then search in the path specified in the LIB environment variable. You can specify only one directory for each /LIBPATH option you
        /// enter. If you want to specify more than one directory, you must specify multiple /LIBPATH options. The linker will then search the specified directories in order.
        ///
        /// </summary>
        public List<string> LibraryPaths { get; set; } = new List<string>();

        /// <summary>
        /// The .lib library files that 'LibraryPaths' points to
        /// E.g: libcpmt.lib  kernel32.lib  libucrt.lib
        /// </summary>
        public List<string> LibraryFiles { get; set; } = new List<string>();

        /// <summary>
        /// The /OUT option overrides the default name and location of the program that the linker creates.
        /// By default, the linker forms the file name using the base name of the first.obj file specified and the appropriate extension (.exe or .dll).
        /// </summary>
        public string OutputFilename { get; set; } = "";

        /// <summary>
        /// You can use the /Fo compiler option to set an output directory for all the object files generated by the CL compiler command. Or, you can use it to rename a single object file. 
        /// </summary>
        public string OutputObjsDir { get; set; } = "";

        public async Task<BuildResult> BuildAsync()
        {
            SetIfExists("/Fo:", _fixLastEscapeBar(OutputObjsDir), false);
            SetIfExists(ExceptionHandlingModelInfo.Get(ExceptionHandlingModel).Param);
            SetIncludes(Includes);
            SetIfExists(Sources.ToArray());

            if (CanUse(LibraryPaths) || CanUse(LibraryFiles))
            {
                Set("/link");
                SetLibPaths(LibraryPaths);
                SetIfExists(LibraryFiles.ToArray());
            }

            SetIfExists("/OUT:", _fixLastEscapeBar(OutputFilename), false);

            AutoTriggerErrors = false;
            return await CreateCommand<BuildResult>(_quotes(MSVC.ProgramPath), cmd.Trim());
        }

        private void SetIncludes(List<string> includes)
        {
            if ((includes != null) && (includes.Count > 0))
            {
                foreach (string include in includes)
                    cmd += "/I\"" + _fixLastEscapeBar(include) + "\" ";
            }
        }

        private void SetLibPaths(List<string> libraries)
        {
            if ((libraries != null) && (libraries.Count > 0))
            {
                foreach (string lib in libraries)
                    cmd += "/LIBPATH:\"" + _fixLastEscapeBar(lib) + "\" ";
            }
        }

        protected override void OnDataReceived(string data)
        {
                 if (data.Contains("): error C"))       CallError(data);
            else if (data.Contains(": fatal error C"))  CallError(data);
            else
                Println("data: " + data);
        }

        protected override void OnErrorDataReceived(string data)
        {
            // not treated as error here because MSVC send non error data on error received event
            Println("data: " + data);
        }

        protected override void OnComplete(BaseResult result)
        {
            Println("[complete]");
        }
    }
}
